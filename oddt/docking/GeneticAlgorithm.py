from __future__ import division, print_function
from itertools import combinations
import numpy as np
from tqdm import tqdm
from joblib import Parallel, delayed
from oddt.docking.internal import generate_rotor_vector
from oddt import random_seed


class GeneticAlgorithm(object):
    def __init__(self, engine, n_population=100, n_generations=150, top_individuals=20,
                 top_parents=20, crossover_prob=0.9, seed=None):
        """
        Implementation of genetic algorithm used in molecular docking. Main goal is to minimize energy of whole
        complex. At every generation new conformations are generated by mutation or crossover between parents,
        then scored and best of them are used to create offspring.

        Parameters
        ----------
        engine: CustomEngine
            Engine with prepared molecules and defined scoring function

        n_population: int
            Population generated on every step

        n_generations: int
            Number of generations (iterations)

        top_individuals: int
            Number of top individuals to survive to next generation

        top_parents: int
            Number of top parents, from which new generation would be generated

        crossover_prob: float
            Probability of crossover between parents. Otherwise conformation is mutated.

        seed: integer
            Number used to initialize a pseudorandom number generator.

        Returns
        -------
        conformation, score: np.array, float
            Best conformation with its score

        """

        self.engine = engine
        self.n_population = n_population
        self.n_generations = n_generations
        self.top_individuals = top_individuals
        self.n_parents = n_population - top_individuals
        self.top_parents = top_parents
        self.crossover_prob = crossover_prob
        self.num_rotors = len(engine.rotors)

        # score initial conformation
        self.best_score = self.engine.score()
        self.best_conformation = self.engine.lig_dict['coords']
        if seed:
            random_seed(seed)

    def perform(self):
        # generate conformations
        conformations = self.generate_conformations()

        for _ in tqdm(range(self.n_generations)):
            # score conformations and sort them by their energy, the lower the better
            sorted_scores_indices = self.analyze_conformations(conformations)

            sorted_conformations = conformations[sorted_scores_indices]
            # pair top conformations and shuffle them (in place)
            if self.n_parents:
                conformations = sorted_conformations[:self.top_parents]
            parents = list(combinations(conformations, 2))
            np.random.shuffle(parents)

            # top individuals (with best scores) are saved for next generation
            current_top_individuals = sorted_conformations[:self.top_individuals]

            generated_offspring = Parallel(
                n_jobs=-1, backend='threading', verbose=0, pre_dispatch='all')(
                delayed(self.generate_child)(parent1, parent2)
                for parent1, parent2 in parents[:self.n_parents])

            # set offspring and top individuals as conformations for next generation
            conformations = np.vstack((current_top_individuals, generated_offspring))

        # compute scores for last generation
        self.analyze_conformations(conformations)

        return self.best_conformation, self.best_score

    def analyze_conformations(self, conformations):
        scores = self.score_conformations(conformations)
        sorted_scores_indices = np.argsort(scores)

        current_step_best_conformation = conformations[sorted_scores_indices[0]]
        current_step_best_score = scores[sorted_scores_indices[0]]
        if current_step_best_score < self.best_score:
            self.best_conformation = current_step_best_conformation
            self.best_score = current_step_best_score
        return sorted_scores_indices

    def generate_conformation(self):
        return self.engine.lig.mutate(generate_rotor_vector(self.num_rotors))

    def generate_conformations(self):
        return np.array([self.generate_conformation() for i in range(self.n_population)])

    def generate_child(self, parent1, parent2):
        if np.random.random() < self.crossover_prob:
            # crossover
            x, y = np.sort(np.random.randint(len(parent1), size=2))
            return np.vstack((parent1[:x], parent2[x:y], parent1[y:]))
        else:
            # mutation
            return self.generate_conformations()[0]

    def score_conformations(self, conformations):
        return np.array([self.engine.score(conformation) for conformation in conformations])
