from __future__ import division, print_function
from itertools import combinations
import numpy as np
from joblib import Parallel, delayed
from oddt.docking.internal import generate_rotor_vector
from oddt import random_seed


class GeneticAlgorithm(object):
    def __init__(self, engine, n_population=100, n_generations=150, top_individuals=20,
                 top_parents=20, crossover_prob=0.9, seed=None):
        """
        Implementation of genetic algorithm used in molecular docking. Main goal is to minimize energy of whole
        complex. At every generation new conformations are generated by mutation or crossover between parents,
        then scored and best of them are used to create offspring.

        Parameters
        ----------
        engine: CustomEngine
            Engine with prepared molecules and defined scoring function

        n_population: int
            Population generated on every step

        n_generations: int
            Number of generations (iterations)

        top_individuals: int
            Number of top individuals to survive to next generation

        top_parents: int
            Number of top parents, from which new generation would be generated

        crossover_prob: float
            Probability of crossover between parents. Otherwise conformation is mutated.

        seed: integer
            Number used to initialize a pseudorandom number generator.

        Returns
        -------
        conformation, score: np.array, float
            Best conformation with its score

        """

        self.engine = engine
        self.n_population = n_population
        self.n_generations = n_generations
        self.top_individuals = top_individuals
        self.n_parents = n_population - top_individuals
        self.top_parents = top_parents
        self.crossover_prob = crossover_prob
        self.num_rotors = len(engine.rotors)

        # score initial conformation
        self.best_score = self.engine.score()
        self.best_conformation = self.engine.lig_dict['coords']
        if seed:
            random_seed(seed)

    def perform(self):
        # generate conformations
        conformations = self.generate_conformations()

        for _ in range(self.n_generations):
            # score conformations and sort them by their energy, the lower the better
            sorted_conformations = self.analyze_conformations(conformations)

            # pair top conformations and shuffle them (in place)
            if self.n_parents:
                conformations = sorted_conformations[:self.top_parents]
            parents = list(combinations(conformations, 2))
            np.random.shuffle(parents)

            # top individuals (with best scores) are saved for next generation
            current_top_individuals = sorted_conformations[:self.top_individuals]

            offspring = [self.generate_child(parent1, parent2)
                         for parent1, parent2 in parents[:self.n_parents]]

            # set offspring and top individuals as conformations for next generation
            conformations = np.vstack((current_top_individuals, offspring))

        # compute scores for last generation
        self.analyze_conformations(conformations)

        return self.best_conformation, self.best_score

    def analyze_conformations(self, conformations):
        """Returns conformations sorted by the scores."""
        scores = self.score_conformations(conformations)
        sorted_conformations = conformations[np.argsort(scores)]

        current_step_best_conformation, current_step_best_score = sorted_conformations[0], scores[0]
        if current_step_best_score < self.best_score:
            self.best_conformation = current_step_best_conformation
            self.best_score = current_step_best_score
        return sorted_conformations

    def generate_conformation(self):
        return self.engine.lig.mutate(generate_rotor_vector(self.num_rotors))

    def generate_conformations(self):
        """Generate new conformations."""
        return np.array([self.generate_conformation() for i in range(self.n_population)])

    def generate_child(self, parent1, parent2):
        """Generate child based on parents coordinates."""
        if np.random.random() < self.crossover_prob:
            # crossover
            x, y = np.sort(np.random.randint(len(parent1), size=2))
            return np.vstack((parent1[:x], parent2[x:y], parent1[y:]))
        else:
            # mutation
            return self.generate_conformations()[0]

    def score_conformations(self, conformations):
        """Score given conformations with scoring function defined for engine."""
        return np.array([self.engine.score(conformation) for conformation in conformations])
